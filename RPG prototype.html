<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>RPG 3D Prototype - QTE Avancé</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; width: 100%; height: 100%; }
    canvas { width: 100%; height: 100%; touch-action: none; }
    #hpText {
      position: absolute; top: 10px; left: 10px;
      color: white; font-family: sans-serif; font-size: 16px;
    }
    #result {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      color: white; font-family: sans-serif; font-size: 24px; text-align: center; display: none;
    }
    #qteContainer {
      display: none; position: absolute; bottom: 60px; left: 50%; transform: translateX(-50%);
      width: 300px; height: 20px; background: #444; border-radius: 10px; overflow: hidden;
    }
    #qteZoneGood {
      position: absolute; left: 100px; width: 100px; height: 100%; background: orange;
    }
    #qteZonePerfect {
      position: absolute; left: 130px; width: 40px; height: 100%; background: lime;
    }
    #qteBar {
      position: absolute; left: 0; width: 10px; height: 100%; background: white;
    }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>
  <div id="hpText">PV Joueur: 100</div>
  <div id="result"></div>
  <div id="qteContainer">
    <div id="qteZoneGood"></div>
    <div id="qteZonePerfect"></div>
    <div id="qteBar"></div>
  </div>

  <script>
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);

    const createScene = function () {
      const scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color3(0.5, 0.8, 1);

      const camera = new BABYLON.ArcRotateCamera("camera", Math.PI/2, Math.PI/3, 20, BABYLON.Vector3.Zero(), scene);
      camera.attachControl(canvas, true);

      const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0), scene);
      BABYLON.MeshBuilder.CreateGround("ground", {width: 50, height: 50}, scene);

      const player = BABYLON.MeshBuilder.CreateBox("player", {size: 2}, scene);
      player.position.y = 1;
      const enemy = BABYLON.MeshBuilder.CreateSphere("enemy", {diameter: 2.5}, scene);
      enemy.position = new BABYLON.Vector3(5, 1.25, 0);

      const arrow = BABYLON.MeshBuilder.CreateCylinder("arrow", {diameterTop: 0, diameterBottom: 0.5, height: 1}, scene);
      arrow.rotation.x = Math.PI;
      arrow.material = new BABYLON.StandardMaterial("arrowMat", scene);
      arrow.material.diffuseColor = BABYLON.Color3.Yellow();

      const hpText = document.getElementById("hpText");
      const resultText = document.getElementById("result");

      let playerHP = 100;
      let enemyHP = 100;
      let isPlayerTurn = true;

      const updateArrow = () => {
        const target = isPlayerTurn ? player : enemy;
        arrow.position = target.position.clone();
        arrow.position.y += 2.5;
      };
      const updateHP = () => hpText.innerText = `PV Joueur: ${Math.max(playerHP, 0)}`;

      function showMessage(msg, color) {
        const div = document.createElement("div");
        div.innerText = msg;
        Object.assign(div.style, {
          position: "absolute", top: "50%", left: "50%", transform: "translate(-50%, -50%)",
          fontSize: "32px", color, fontFamily: "sans-serif"
        });
        document.body.appendChild(div);
        setTimeout(() => div.remove(), 1000);
      }

      // QTE ping-pong barre
      function startQTE(callback) {
        const container = document.getElementById("qteContainer");
        const bar = document.getElementById("qteBar");
        container.style.display = "block";
        bar.style.left = "0px";

        let start = performance.now();
        const duration = 2000; // temps pour un aller simple
        let direction = 1; // 1 = droite, -1 = gauche

        let animationId;

        function animate() {
          let now = performance.now();
          let elapsed = now - start;
          let pct = elapsed / duration;

          if (pct >= 1) {
            direction *= -1;
            start = now;
            pct = 0;
          }

          let pos = direction === 1 ? pct * 290 : 290 - pct * 290;
          bar.style.left = `${pos}px`;

          animationId = requestAnimationFrame(animate);
        }

        function endQTE(result) {
          cancelAnimationFrame(animationId);
          container.style.display = "none";
          window.removeEventListener("keydown", onKey);
          callback(result);
        }

        function onKey(e) {
          if (e.code === "Space") {
            const x = parseFloat(bar.style.left);
            if (x >= 130 && x <= 170) return endQTE("perfect");
            else if (x >= 100 && x <= 200) return endQTE("good");
            else return endQTE("fail");
          }
        }

        window.addEventListener("keydown", onKey);
        animate();
      }

      // Fonction attaque ennemie avec chance critique et QTE esquive joueur
      function enemyAttack() {
        const isCritical = Math.random() < 0.2;
        const baseDamage = Math.floor(Math.random() * 20) + 5;

        startQTE((result) => {
          let damage;

          if (result === "perfect") {
            damage = 0;
            showMessage("Esquive parfaite !", "lime");
          } else if (result === "good") {
            damage = Math.floor(baseDamage / 2);
            showMessage("Bonne esquive !", "orange");
          } else {
            damage = isCritical ? baseDamage * 2 : baseDamage;
            showMessage(isCritical ? "Coup critique ennemi !" : "Touché !", "red");
          }

          playerHP -= damage;
          updateHP();

          if (playerHP <= 0) {
            resultText.innerHTML = "Vous avez perdu !";
            resultText.style.display = 'block';
          } else {
            isPlayerTurn = true;
            updateArrow();
          }
        });
      }

      window.attackEnemy = () => {
        if (!isPlayerTurn || playerHP <= 0 || enemyHP <= 0) return;
        isPlayerTurn = false;
        updateArrow();

        startQTE((result) => {
          setTimeout(() => {
            const dmg = result === "perfect" ? 40 : result === "good" ? 30 : 20;
            enemyHP -= dmg;
            enemy.material.diffuseColor = result === "perfect" ? BABYLON.Color3.Yellow() : BABYLON.Color3.Red();
            setTimeout(() => enemy.material.diffuseColor = BABYLON.Color3.White(), 300);

            if (result !== "fail") showMessage("Coup critique !", "gold");

            if (enemyHP <= 0) {
              resultText.innerHTML = "Vous avez gagné !";
              resultText.style.display = 'block';
            } else {
              enemyAttack();
            }
          }, 100);
        });
      };

      window.healPlayer = () => {
        if (!isPlayerTurn || playerHP <= 0) return;
        isPlayerTurn = false;
        updateArrow();
        setTimeout(() => {
          playerHP = Math.min(100, playerHP + 15);
          player.material.diffuseColor = BABYLON.Color3.Green();
          setTimeout(() => player.material.diffuseColor = BABYLON.Color3.White(), 300);
          updateHP();
          enemyAttack();
        }, 100);
      };

      window.addEventListener('keydown', e => {
        if (e.key === 'a' || e.key === 'A') attackEnemy();
        if (e.key === 'w' || e.key === 'W') healPlayer();
      });

      updateArrow();
      updateHP();
      return scene;
    };

    const scene = createScene();
    engine.runRenderLoop(() => {
      const arrow = scene.getMeshByName("arrow");
      arrow.position.y += Math.sin(performance.now()/200) * 0.005; // petite animation up/down
      scene.render();
    });

    window.addEventListener("resize", () => engine.resize());
  </script>
</body>
</html>
